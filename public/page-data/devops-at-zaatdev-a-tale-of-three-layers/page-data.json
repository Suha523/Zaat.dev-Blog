{"componentChunkName":"component---src-templates-single-post-js","path":"/devops-at-zaatdev-a-tale-of-three-layers/","result":{"data":{"markdownRemark":{"html":"<p>We, at Zaat.dev host multiple websites and applications on a single instance. Yeah, it may seem a little bit confusing to call it an “instance” or \"dyno\"(heroku) even if you’re into OOP, it’s like taking the OOP concept to a whole new level. That’s why terminology is a crucial thing, one should master, regarding their field of specialization, and to be aware of how tricky words can be, this is why scientists invent long weird terms, as they prefer to create complicated terms instead of simple conflicting ones.</p>\n<p>So here, an instance <em>is a Linux run environment (bash terminal), that is supposed to be available 24/7 while maintaining its static IP address</em>.\r\nAn instance can be rented from <a href=\"https://aws.amazon.com/\">AWS</a>, <a href=\"https://azure.microsoft.com/en-us/\">Azure</a>, or <a href=\"https://cloud.google.com/\">GCP</a>. They have almost the same pricing, unless your company is big enough to have a couple of those men in suits, you may have a chance to cut a deal with them to get a better price!</p>\n<p>Now and after defining what an instance means, we’ll go over the three main layers, as a <strong>top to bottom approach</strong>, then I will introduce some trivial code snippets but starting from as a <strong>bottom to top</strong>.</p>\n<h3>Domain Name Servers: First Layer</h3>\n<p>You can consider the domain name servers as a phone contacts app, through it, you can store your family members and friends numbers, so whenever you want to reach them out, you just type their names and give them a call. This feature is basic but important and any domain you buy should support it.\r\nNowadays, things got a little bit complicated by dropping the old fashion “www” from websites’ addresses, even though you still can have the same domain name with different prefixes. Going back to our ref example, the phone contacts app, is there any chance that this app doesn't support adding multiple phone numbers in a single contact!</p>\n<p>So, let's say that you have several subdomains like “mail.example.com”, “app.example.com”, etc and you want these subdomains to point to your main domain name “example.com”, you can do this by using the CNAME record. As mentioned before, it is exactly like the phone contacts app, where you can add multiple phone numbers in a single contact under different labels, e.g: work, home, etc.</p>\n<p>Domain names are an extra layer added over a typical IP layer, so when users want to visit a site they don’t have to memorize numbers -IPs-, just like phone numbers! Each time you want to call someone, you just type their name on the phone contacts app without worrying about what their actual phone number is. However, domain names are registered across the web and distributed around the globe. Each registry has two main values: the IP “32.34.23.34” and a corresponding domain name “zaat.dev”. So when you type in a URL, the browser looks up the IP address for the domain name, then the browser sends a request to the server, the server sends back a response, if everything is OK the browser then redirects the request to the second layer…</p>\n<h3>Nginx: Alternative Apache</h3>\n<p><a href=\"https://nginx.org\">Nginx</a> is the main gate for the instance, Nginx is like a traffic officer, its main role is to direct the request according to thier CNAME, URL, etc. to its destination in our instance.</p>\n<p>To make it clearer, consider Nginx as a help desk for an organization that redirects requests to the right destination.(nginx usually does that mainly by matching the host name or CNAME with the first server block). If the requests were simple, Nginx can directly reopens to them (e.g. serving static files). Otherwise, Nginx can proxy the requests to a localhost server, it can be a node app, Django, Java enterprise, or any other localhost server you are running.</p>\n<p>Since Nginx is our main gate, it makes sense to let it handle the encryption layer, i.e. https. Frounttently, <a href=\"https://certbot.eff.org/\">certbot</a>(built on top of the amazing open source tool <a href=\"https://www.openssl.org/\">openssl</a>) does that out of the box, as soon as you set the basic configuration for Nginx. Certbot can transform all of your http to https in just one command line.</p>\n<p>Other features Nginx may offer, or that it is commonly used for, is to intervene with request headers. For example, Nginx could add geolocation headers for each request by interrupting the requested IP address. Then, it can for example redirect it to a localized version of the app/site or set specific headers accordingly.</p>\n<h3>Third Layer: Local Server, File System, a Containerized App</h3>\n<p>In this layer, we handle the services or local servers which Nginx has proxy . At Zaat.dev, almost all of our apps are node-based, so it’s easy to manage the running app using <a href=\"https://pm2.keymetrics.io/\">pm2</a>.</p>\n<h3>Let’s get our hands dirty! (Bottom-up)</h3>\n<h3>First Layer: pm2/built files</h3>\n<p>Pm2 could be used in a simple or sophisticated way. Let’s assume you have nodejs app, which definitely has “package.json” with a start script, all what you need to do with pm2 is to let it run is:</p>\n<pre><code class=\"language-bash\">pm2 start --name myapp \"node start\" // you can pass port number here, otherwise pm2 take app default, lets assume port is 5000 here\n</code></pre>\n<p>Alright, now suppose, you have static website, no matter which framework it is based on,usually static sites are built before being deployed, and once built it usually at files are put in a specific directory. Let's assume your site has build script in <code>package.json</code>, and its output directory is <code>/build</code></p>\n<pre><code class=\"language-bash\">npm run build // directory is site_root/build\n</code></pre>\n<h3>Second Layer: Nginx</h3>\n<p>Now that we have a static site built and another app running on localhost, we can set the configuration of nginx as follows:</p>\n<p>Note: usually the default configuration file for (ubuntu) is\r\n<code>etc/ngnix/conf.d/default.conf</code> // this what we are editing next.\r\nBut don't confuse with the other configuration file <code>/etc/nginx/nginx.conf </code>,\r\nwhich usually seems to be used for parent or top level configuration like logs..etc\r\nAlso notice that my nginx.conf file has an important statement in it's http block:\r\n{\r\n// some configuration, max file size, type and logs..etc\r\n<code>include /etc/nginx/conf.d/*.conf;</code>\r\n}\r\nThis means all the files <code>/conf.d</code> which has the <code>.conf</code> extension, read them and use them as configuration.</p>\n<p>Now back to the other configuration file, we are adding this server block:\r\nWhich means whenever we get a request with hostname app.example.com, proxy it local server at port 5000</p>\n<pre><code class=\"language-nginx\">server {\r\n\r\n    server_name app.example.com;\r\n\r\n    location / {\r\n         proxy_pass http://127.0.0.1:5000;\r\n\r\n        }\r\n\r\n}\n</code></pre>\n<p>And for the site we can do something like:</p>\n<pre><code class=\"language-nginx\">server {\r\n\r\n    server_name .exaxmple.com www.example.com;\r\n    root /home/ubuntu/site_root/build;\r\n    location / {\r\n           index: index.html // path is relative to the root\r\n    }\r\n\r\n}\n</code></pre>\n<p>Now, that your configuration is ready, you can restart the nginx, by running\r\nFirst make sure no syntax error in configuration, we run:</p>\n<pre><code class=\"language-bash\">sudo service nginx reload\n</code></pre>\n<p>Re starting nginx with the tested configuration by previous step.</p>\n<pre><code class=\"language-bash\">sudo service nginx restart\n</code></pre>\n<p><strong>Note:</strong> It's importnat each time you change the nginx configuration to run <code>reload</code> first, otherwise all your servies may be down until you fix a syntax error!.</p>\n<p>Lastly, as mentioned before, certbot can easliy add an encryption layer for all the servers that are handled by nginx. you just need to tell it you are using nginx, then it reads the its configuration file, check which domain name are setted then asked you accordingly which one of them you want to add encryption layer for..etc\r\nOn success, certbot rewrite the configuration file accordingly, e.g. setting path of generated key pairs...</p>\n<p>Im summary it could be as easy as this, refer to this <a href=\"https://certbot.eff.org/lets-encrypt/ubuntubionic-nginx\">doc</a> for more information.</p>\n<pre><code class=\"language-bash\">sudo certbot --nginx\n</code></pre>\n<p>Alright, at this point we are done with the instance in the shell/bash level, but before setting the domain name, you need to make sure your instance is running on a static ip and to get it. With AWS this is easy, you would need allocate an elastic ip address then assign/assoicated it to the running instance.\r\nLet's assume our static ip address is \"34.250.253.64\"</p>\n<h3>Third layer: Domain Name</h3>\n<p>First thing first, is to tell your domain register service, is to direct all requests (root) to the ip address, each configuration setting is called a <em>record</em></p>\n<p>So add an 'a' record to with the ip address, in our case \"34.250.253.64\"\r\nAdd a cname record, called 'app' and redirects to the root, first record.</p>\n<p>Note: you can set the <code>www</code> direction at the domain name level or at the nginx level, though you did it at nginx I think it would redirect faster if at the domain level.</p>\n<p>Here is how the configuration may look like, if you are using google domain: (ignore the admin record).</p>\n<p><img src=\"./google_domain_shot.png\" alt=\"Google domain screen shot\"></p>\n<p>Lastly and more importantly: You can make other sites (domain names) listen to your instance/ the nginx server, simply by setting their root ip same as the original level, and then adding a new server block in nginx configuration accordingly.</p>\n<h3>The more I know the less I know...</h3>\n<p><strong>Note:</strong> This may not be the best approach, i.e. running all of your apps under a single instance, consider the situation of which while you are trying to update an app but you have to upgrade node before, but other apps are dependent on the current specific version!..etc And this I guess is where Docker/Kubernates should play a critical role, hope this may be a story for another day..</p>\n<p>Thank you for your time, hope this article was useful for you, happy to answer your question or to hear your suggestion, you can use the link below to comment on github.</p>\n<p>I want also to take the chance to thank our content creator <a href=\"https://github.com/AbeerAlbada\">Abeer Albada</a> for helping me put my word together in the first part of this article. Much appreciate Abeer!.</p>","frontmatter":{"title":"DevOps at zaat.dev a tale of three layers","tags":"DevOps, AWS, nginx, domains, pm2, node, tutorial, guide","date":"10/17/2020","author_twitter":"ghassanmas","author_title":"A byte of everything","author_company":"zaat.dev","author":"Ghassan Maslamani","author_github":"ghassanmas","description":"How to run all of your apps and/or sites under a single instance","issue_number":13,"image":{"childImageSharp":{"fluid":{"src":"/static/4e24321ba24fd6e2bf7e3615d05b10ed/fd01f/cover_devops.png","base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQY0wGrAVT+AA8zkRc8nCNHpy5Ssjtfv0dpx1NzzWKA2HCM4X+X5X+V4HWH0llrtiQweCUjVmFPYjM+ehEeXQMJRQADPQArQp8uTaozV7VDY79RasNdedFuh9lvhdRUW52HicVsfcIqMG5LOmdWRG5oTWxUP2A6L1AtKlMQI15NQE8AhGWDREaMMkabOU+eQD96T1GTUleYV1CEUDpogmF8rnt/snVtw4Btv3RnpFZZqE9Jv15HwFdDmUBHqkhCAL2Dd3lidZNtZEc2X0s7V3hXbCUsZywybyYmV3dFVNFzXdyCaMp7aLNwbMuJePOpdd57U9FcOtBOKqwvIwB5VD29XC+dVTtAJz1sV3VBO2sNF1QcLXcUImMpI1pcNVORR0u5V0vHYlHbflnyqWrMj2ixg2Cgb1aVV0gADggeHgggCQk3MkB+OkGLCQ0/EhdMIzB0Ii1yGh9aFB5cJCdgNypYZjhXlEdXt0xKnjg9biMyQBUwLRc7ABAKIgsUQy9BkEBEjxkYSAsJLBoaTyAlYCg0dyAjXh0bThMbUB8lWycjUzIkT0IvWGA6XIA7UoctOnUcJwAElm2KW4YkAAAAAElFTkSuQmCC","aspectRatio":3,"srcSet":"/static/4e24321ba24fd6e2bf7e3615d05b10ed/42e27/cover_devops.png 150w,\n/static/4e24321ba24fd6e2bf7e3615d05b10ed/95505/cover_devops.png 300w,\n/static/4e24321ba24fd6e2bf7e3615d05b10ed/fd01f/cover_devops.png 600w,\n/static/4e24321ba24fd6e2bf7e3615d05b10ed/ef3d3/cover_devops.png 900w,\n/static/4e24321ba24fd6e2bf7e3615d05b10ed/e41ba/cover_devops.png 1200w,\n/static/4e24321ba24fd6e2bf7e3615d05b10ed/af542/cover_devops.png 2000w","sizes":"(max-width: 600px) 100vw, 600px"}}}},"excerpt":"We, at Zaat.dev host multiple websites and applications on a single instance. Yeah, it may seem a little bit confusing to call it an “instance” or \"dyno\"(heroku) even if you’re into OOP, it’s like taking the OOP concept to a whole new level. That’s why terminology is a crucial thing, one should master, regarding their field of specialization, and to be aware of how tricky words can be, this is why scientists invent long weird terms, as they prefer to create complicated terms instead of simple conflicting ones. So here, an instance is a Linux run environment (bash terminal), that is supposed to be available 24/7 while maintaining its static IP address.\r\nAn instance can be rented from AWS, Azure, or GCP. They have almost the same pricing, unless your company is big enough to have a couple of those men in suits, you may have a chance to cut a deal with them to get a better price! Now and after defining what an instance means, we’ll go over the three main layers, as a top to bottom approach, then I will introduce some trivial code snippets but starting from as a bottom to top. Domain Name Servers: First Layer You can consider the domain name servers as a phone contacts app, through it, you can store your family members and friends numbers, so whenever you want to reach them out, you just type their names and give them a call. This feature is basic but important and any domain you buy should support it.\r\nNowadays, things got a little bit complicated by dropping the old fashion “www” from websites’ addresses, even though you still can have the same domain name with different prefixes. Going back to our ref example, the phone contacts app, is there any chance that this app doesn't support adding multiple phone numbers in a single contact! So, let's say that you have several subdomains like “mail.example.com”, “app.example.com”, etc and you want these subdomains to point to your main domain name “example.com”, you can do this by using the CNAME record. As mentioned before, it is exactly like the phone contacts app, where you can add multiple phone numbers in a single contact under different labels, e.g: work, home, etc. Domain names are an extra layer added over a typical IP layer, so when users want to visit a site they don’t have to memorize numbers -IPs-, just like phone numbers! Each time you want to call someone, you just type their name on the phone contacts app without worrying about what their actual phone number is. However, domain names are registered across the web and distributed around the globe. Each registry has two main values: the IP “32.34.23.34” and a corresponding domain name “zaat.dev”. So when you type in a URL, the browser looks up the IP address for the domain name, then the browser sends a request to the server, the server sends back a response, if everything is OK the browser then redirects the request to the second layer… Nginx: Alternative Apache Nginx is the main gate for the instance, Nginx is like a traffic officer, its main role is to direct the request according to thier CNAME, URL, etc. to its destination in our instance. To make it clearer, consider Nginx as a help desk for an organization that redirects requests to the right destination.(nginx usually does that mainly by matching the host name or CNAME with the first server block). If the requests were simple, Nginx can directly reopens to them (e.g. serving static files). Otherwise, Nginx can proxy the requests to a localhost server, it can be a node app, Django, Java enterprise, or any other localhost server you are running. Since Nginx is our main gate, it makes sense to let it handle the encryption layer, i.e. https. Frounttently, certbot(built on top of the amazing open source tool openssl) does that out of the box, as soon as you set the basic configuration for Nginx. Certbot can transform all of your http to https in just one command line. Other features Nginx may offer, or that it is commonly used for, is to intervene with request headers. For example, Nginx could add geolocation headers for each request by interrupting the requested IP address. Then, it can for example redirect it to a localized version of the app/site or set specific headers accordingly. Third Layer: Local Server, File System, a Containerized App In this layer, we handle the services or local servers which Nginx has proxy . At Zaat.dev, almost all of our apps are node-based, so it’s easy to manage the running app using pm2. Let’s get our hands dirty! (Bottom-up) First Layer: pm2/built files Pm2 could be used in a simple or sophisticated way. Let’s assume you have nodejs app, which definitely has “package.json” with a start script, all what you need to do with pm2 is to let it run is: Alright, now suppose, you have static website, no matter which framework it is based on,usually static sites are built before being deployed, and once built it usually at files are put in a specific directory. Let's assume your site has build script in package.json, and its output directory is /build Second Layer: Nginx Now that we have a static site built and another app running on localhost, we can set the configuration of nginx as follows: Note: usually the default configuration file for (ubuntu) is\r\netc/ngnix/conf.d/default.conf // this what we are editing next.\r\nBut don't confuse with the other configuration file /etc/nginx/nginx.conf ,\r\nwhich usually seems to be used for parent or top level configuration like logs..etc\r\nAlso notice that my nginx.conf file has an important statement in it's http block:\r\n{\r\n// some configuration, max file size, type and logs..etc\r\ninclude /etc/nginx/conf.d/*.conf;\r\n}\r\nThis means all the files /conf.d which has the .conf extension, read them and use them as configuration. Now back to the other configuration file, we are adding this server block:\r\nWhich means whenever we get a request with hostname app.example.com, proxy it local server at port 5000 And for the site we can do something like: Now, that your configuration is ready, you can restart the nginx, by running\r\nFirst make sure no syntax error in configuration, we run: Re starting nginx with the tested configuration by previous step. Note: It's importnat each time you change the nginx configuration to run reload first, otherwise all your servies may be down until you fix a syntax error!. Lastly, as mentioned before, certbot can easliy add an encryption layer for all the servers that are handled by nginx. you just need to tell it you are using nginx, then it reads the its configuration file, check which domain name are setted then asked you accordingly which one of them you want to add encryption layer for..etc\r\nOn success, certbot rewrite the configuration file accordingly, e.g. setting path of generated key pairs... Im summary it could be as easy as this, refer to this doc for more information. Alright, at this point we are done with the instance in the shell/bash level, but before setting the domain name, you need to make sure your instance is running on a static ip and to get it. With AWS this is easy, you would need allocate an elastic ip address then assign/assoicated it to the running instance.\r\nLet's assume our static ip address is \"34.250.253.64\" Third layer: Domain Name First thing first, is to tell your domain register service, is to direct all requests (root) to the ip address, each configuration setting is called a record So add an 'a' record to with the ip address, in our case \"34.250.253.64\"\r\nAdd a cname record, called 'app' and redirects to the root, first record. Note: you can set the www direction at the domain name level or at the nginx level, though you did it at nginx I think it would redirect faster if at the domain level. Here is how the configuration may look like, if you are using google domain: (ignore the admin record). Google domain screen shot Lastly and more importantly: You can make other sites (domain names) listen to your instance/ the nginx server, simply by setting their root ip same as the original level, and then adding a new server block in nginx configuration accordingly. The more I know the less I know... Note: This may not be the best approach, i.e. running all of your apps under a single instance, consider the situation of which while you are trying to update an app but you have to upgrade node before, but other apps are dependent on the current specific version!..etc And this I guess is where Docker/Kubernates should play a critical role, hope this may be a story for another day.. Thank you for your time, hope this article was useful for you, happy to answer your question or to hear your suggestion, you can use the link below to comment on github. I want also to take the chance to thank our content creator Abeer Albada for helping me put my word together in the first part of this article. Much appreciate Abeer!."}},"pageContext":{"slug":"devops-at-zaatdev-a-tale-of-three-layers"}},"staticQueryHashes":["3649515864","63159454"]}